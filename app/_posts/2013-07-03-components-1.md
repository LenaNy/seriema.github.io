---
layout: post
title: Components part 1 - Simple solution to self-registering JS components
---

### Intro
On a project, we were to build a whole eCommerce website from scratch. I had been involved in the UX design of it so I knew what kind of things we needed. We decided to borrow a few things, but make most of it ourselves. Since we used LESS for CSS that was easier to manage, even though the grouping wasn't clear from the start. The project used Java for the backend so JSP, JSTL and `tags` allowed a great level of reuse of the HTML, although I wasn't sure on what level to group the markup. My biggest problem was managing all the JavaScript though. I needed a system that would solve these three issues, and be highly reusable. In this series I present the component-system I created. Each part takes you through one iteration so things start easy, but end with something quite powerful.

### What's out there
There are several widget-like components out there, like [jQuery UI]() and [Twitter Bootstrap](). Personally I feel constrained by the 'magic' HTML generated by jQuery. Changing a look and feel is a complex process using their special 'theme' method. Bootstrap has a much nicer setup IMHO and I was intrigued by the data-hooks you could use to get the JavaScript to notice and run on your markup. Although I think having different data-attributes for every component makes it splintered and inconsistent.

In Bootstrap, you add JavaScript logic to your components like this:
{% highlight javascript %}
// lookup an element and run a Bootstrap function
$('#my-tabs').tabs();
{% endhighlight %}
or this:
{% highlight html %}
<!-- mark an element so it's found by Bootstrap -->
<div data-tabs="true" ...>
{% endhighlight %}

Then to get it to look correctly, you also have to add a class.

{% highlight html %}
<div class="tabs-nav" data-tabs="true">
{% endhighlight %}

### My take on it

I liked the idea and needed something to create more components. I was also struggling with the amounting JavaScript for various parts of the page. Instead of creating a `.js` file per page, I went with a component-model. I wanted the styling and JavaScript to be applied with the same selectors. Not having to add both a class and data-hook when one should be enough.

Since I was using LESS I naturally gravitated to have a "scope" for each component style.

{% highlight css %}
.my-comp {
    /* styling here */
}
{% endhighlight %}


Class names are easy, but data-attributes are valid too.

{% highlight css %}
[data-hook="my-comp"] {
    /* styling here */
}
{% endhighlight %}

Which one to use? I opted for speed and did [some tests](), which concluded that class names were the obvious choice. Since I had recently read [SMACSS]() I decided to prefix the class-name of my "modules", as the author called it. He used "mod-", but I went with "comp-".

This required some discipline: the class-names (and thus, names) needed to be unique. The upside was that it only had to be unique per component, so it could show up multiple times on a page (unlike ID's).

Every component resides in its own set of files. The styling in a LESS file and the logic in a JS file, both with the name of the component. The HTML can be any of a myriad of different types of files, from TAG files in Java to Handlebar templates. Regardless, everything is kept together with the names.

`tabs.html`
{% highlight html %}
<div class="comp-tabs"> ... </div>
{% endhighlight %}

`tabs.less`
{% highlight css %}
.comp-tabs { ... }
{% endhighlight %}

The components should allow for complicated JS if needed, but still be based on instances and not collide with each other. After a lot of thinking and experimenting I found my philosophers stone and still marvel at the simplicity of it:

`tabs.js`
{% highlight javascript %}
$('.comp-tabs').each(function() {
    var $root = $(this);

    // Do the stuff
});
{% endhighlight %}